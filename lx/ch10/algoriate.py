find(首迭代器,尾迭代器,需查找的数据)
如果找到,返回第一个查找到的数据位置信息,没找到就返回一个尾迭代器

count(首迭代器,尾迭代器,需计数数据)
在首尾迭代器所包含的(不包括尾迭代器)数据范围内,查找并统计与计数数据相等的数据
返回范围内出现次数

accumulate(首迭代器,尾迭代器,初始数据)
这函数头文件numeric,用来求首尾迭代器所圈定的数据总和

equal(v1.begin(),v1.end(),v2.begin(),v2.end())
参数4个,用来比较两个序列的内容是否一致,而不关心类型是否一致

fill(首迭代器,尾迭代器,待填充数据)
将待填充数据填充进首尾迭代器所圈定的范围数据内,原有数据覆盖掉


fill_n(首迭代器,计数数据,待填充数据)
与fill相同,唯一不同的就是能指定范围填充,
不过空容器不能使用,会报错

back_inseter
迭代器,专往人屁股上插的,头文件iterator

copy(首迭代器,尾迭代器,目标位置)
拷贝在首尾迭代器所圈定的范围里的字符到目标位置

replace(首迭代器,尾迭代器,待修改数据,修改数据)
读入一个序列,查找待修改数据,找到之后,用修改数据覆盖掉

replace_copy(首迭代器,尾迭代器,输出位置的迭代器,待修改数据,修改数据)
简单来说就是把replace和copy两个函数合并起来了

sort(首迭代器,尾迭代器)
按从小到大排序

unique(首迭代器,尾迭代器)
erase(unique返回的迭代器,尾迭代器)
unique将重复元素移到后面,返回一个迭代器,不改变容器大小,erase则是删除迭代器内的元素,它改变容器大小

谓词
即参数,如在sort里面增加一个参数

lambda表达式
[](parameters) mutable->return_type{body}
[]:捕获子句,用于指定lambda表达式内部可以访问的外部变量
parameters:参数列表,与普通函数的参数列表相同
mutable:(可选)如果lambda表达式需要修改捕获的外部变量,需要指定mutable
->return_type:(可选)返回类型,如果lambda表达式体中包含单一的返回语句,编译器可以自动推导返回类型
{body}:函数体,与普通函数的函数体相同
[&]:捕获所有外部变量的引用
[=]:捕获所有外部变量的副本
[&var]:捕获名为var的变量的引用
[var]:捕获名为var的变量的副本
[this]:捕获当前类的this指针

find_if(首迭代器,尾迭代器,谓词)
根据谓词条件来查找数据,可能是一个,也可能是一组数据

for_each(首迭代器,尾迭代器,操作子)
其中操作子为操作+元素,即一切可操作对象皆为操作子

bind(想要绑定的函数,想要绑定的函数参数)
头文件functional
函数参数可能有多个

placeholders
占位符std::placeholders::_1
