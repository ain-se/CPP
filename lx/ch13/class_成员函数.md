拷贝构造函数
class Foo
{
public:
Foo();//默认构造函数
Foo(const Foo&);//拷贝构造函数
~Foo(){};//析构函数,用于类的收尾工作
}
explicit禁止函数被编译器隐式转换
析构无参无返回值
构造函数可以有多个,但析构函数只能有一个
默认的无参无函数体,只有构造和析构才有默认
析构=delete是错误的,构造虽然可以delete,但麻烦
一旦显式使用构造析构函数,类就不会生成默认构造析构函数了
